<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>使用ConstraintLayout构建响应式布局</title>
    <url>/2019/01/24/ConstraintLayout/</url>
    <content><![CDATA[<h2 id="1-简介"><a href="#1-简介" class="headerlink" title="1 简介"></a>1 简介</h2><blockquote>
<p>使用ContraintLayout能够使用平铺的布局方式（没有层级嵌套）创建大而复杂的布局。和RelativeLayout类似，ConstraintLayout所有的View都在同一层级中，但是它比RelativeLayout使用起来更加灵活，结合Android Studio的布局编辑器，使用起来也更加简单。</p>
<p>ContraintLayout的API和Android Studio的布局编辑器的图形化工具是相辅相成的，通过布局编辑器的图形化工具，可以直接使用ConstraintLayout的全部特性。在使用ConstraintLayout时，可以直接拖拽进行布局，完全不用编辑xml。</p>
<p>ConstraintLayout支持Android 2.3(API 9)以上，本文是在Android Studio 3.0及以上版本中使用ConstraintLayout的教程，如果想要了解Android Studio中更多关于布局编辑器的内容，可以参考官网<a href="https://developer.android.com/studio/write/layout-editor.html">Build a UI with Layout Editor</a>。</p>
<p>如果想要看ConstraintLayout的Demo，可以去GitHub上围观：<a href="https://github.com/googlesamples/android-ConstraintLayoutExamples">https://github.com/googlesamples/android-ConstraintLayoutExamples</a>。</p>
</blockquote>
<h2 id="2-约束预览"><a href="#2-约束预览" class="headerlink" title="2 约束预览"></a>2 约束预览</h2><blockquote>
<p>要确定一个View在ConstraintLayout中的位置，至少需要指定一个水平或者垂直的约束。每一个约束都代表了一个View和其它的View，其父View或者不可见的基准线之间的联系或者对齐关系。每一个约束都定义了View相对于横轴和纵轴的位置，因此，确定一个View的位置必须至少相对于横轴和纵轴各指定一个约束，通常来说，我们需要指定的约束会有多个。</p>
<p>在Android Studio中，当把一个View拖到布局编辑器中的时候，这个View一般会显示在你拖动的位置，但是这仅仅是为了便于我们编辑，如果一个View一个约束也没有，那它会显示在坐标[0, 0]的位置，即左上角。</p>
</blockquote>
<p>比如下面的两种情况：</p>
<center>
![图1 A和C没有约束](http://ww1.sinaimg.cn/large/afdaace3ly1fnpf0fiigij20cw068dfr.jpg)</br>
图1 A和C没有约束
</center>

<center>
![图2 A和C有约束](http://ww1.sinaimg.cn/large/afdaace3ly1fnpf10sjdgj20cw068dfu.jpg)</br>
图2 A和C有约束
</center>

<p>图1中，A和C没有约束关系，尽管在预览时会看到C在A的下方，实际运行时，C会浮到屏幕的最顶端。图2中，加上了A和C的约束(红圈所示)之后，C就会位于A的下方。</p>
<h2 id="3-配置ConstraintLayout"><a href="#3-配置ConstraintLayout" class="headerlink" title="3 配置ConstraintLayout"></a>3 配置ConstraintLayout</h2><ol>
<li><p>maven仓库的配置</p>
<p>在最新版本的gradle中，Google迁移了maven仓库，所以需要在项目根目录的build.gradle中添加：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">repositories &#123;</span><br><span class="line">   maven &#123;</span><br><span class="line">       url &#39;https:&#x2F;&#x2F;maven.google.com&#39;</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>或者是</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">repositories &#123;</span><br><span class="line">       jcenter()</span><br><span class="line">       google()</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>添加gradle最新版本的依赖，目前稳定版本是1.0.2，1.1.0还是beta版。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">dependencies &#123;</span><br><span class="line">    compile &#39;com.android.support.constraint:constraint-layout:1.0.2&#39;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li><p>同步gradle</p>
</li>
</ol>
<h2 id="4-在项目中使用ConstraintLayout"><a href="#4-在项目中使用ConstraintLayout" class="headerlink" title="4 在项目中使用ConstraintLayout"></a>4 在项目中使用ConstraintLayout</h2><p>在Android Studio 3.0+中，可以把旧的布局转换成ConstraintLayout，也可以在新建Constraint<br>Layout。如果没做特别的配置，使用Android Studio的Activity模版新建Activity时，布局文件根布局会默认是ConstraintLayout。</p>
<p>将普通布局文件转换成ConstraintLayout：<br>切到Design面板-&gt;打开Component Tree-&gt;右键选中一个Layout，选择Convert XXXLayout to ConstraintLayout；</p>
<center>
![](http://ww1.sinaimg.cn/large/afdaace3ly1fnqks0e1w4j20n20i5q38.jpg)</br>
图3 将普通布局转换成Constraint
Layout</center>

<h2 id="5-实战练习"><a href="#5-实战练习" class="headerlink" title="5 实战练习"></a>5 实战练习</h2><h3 id="5-1-添加相对于父布局的位置约束"><a href="#5-1-添加相对于父布局的位置约束" class="headerlink" title="5.1 添加相对于父布局的位置约束"></a>5.1 添加相对于父布局的位置约束</h3><p>新建一个布局文件，根布局选择为ConstraintLayout，切换到Design面板</p>
<center>
![](http://ww1.sinaimg.cn/large/afdaace3ly1fnqluzldu4j21ue19sn4v.jpg)</br>
图4 新建一个的ConstraintLayout
</center>

<p>拖动一个控件到面板中，此时没有任何约束，会看到控件上报了一个错误，提示没有约束，如果直接运行，这个TextView会显示到屏幕的左上角</p>
<center>
![](http://ww1.sinaimg.cn/large/afdaace3ly1fnqlxou6m8j21u817ewm2.jpg)
图5 未添加约束时的警告
</center>

<p>添加相对于父布局的约束，在一个方向上可以添加一个或者两个约束</p>
<center>
![](http://ww1.sinaimg.cn/large/afdaace3ly1fnqm9npfx3g20pk0g4172.gif)</br>
图6 添加左侧的约束
![](http://ww1.sinaimg.cn/large/afdaace3ly1fnqmn6pigmg20pk0g4atu.gif)</br>
图7 添加右侧的约束
</center>

<h3 id="5-2-添加相对于兄弟View的位置约束"><a href="#5-2-添加相对于兄弟View的位置约束" class="headerlink" title="5.2 添加相对于兄弟View的位置约束"></a>5.2 添加相对于兄弟View的位置约束</h3><p>添加相对于其它View的约束，下图中B、C只添加了对A的约束，运行起来后，B贴在屏幕顶部且在A的右边，C贴在屏幕的左侧且位于A的下方。</p>
<center>
![](http://ww1.sinaimg.cn/large/afdaace3ly1fnqmvdktk7j215q0yctb7.jpg)
</br>
图7 相对于其它View的约束

<p><img src="http://ww1.sinaimg.cn/large/afdaace3ly1fnqswt7oohj20ko1240yx.jpg"><br>图8 运行的实际效果</p>
</center>

<h3 id="5-3-添加对齐方式"><a href="#5-3-添加对齐方式" class="headerlink" title="5.3 添加对齐方式"></a>5.3 添加对齐方式</h3><p>在两个View的同一个方向(水平或垂直)上，把两个View的两条边连接起来即可添加对其约束。添加对其约束之后，laytou_marginXXX等属性仍然会生效。</p>
<center>
![](http://ww1.sinaimg.cn/large/afdaace3ly1fnqnp0oot8j215o0y6mzp.jpg)
</br>
图9 C与A的左侧对其，B与A的顶部对其且向下偏移16dp
</center>

<h3 id="5-4-删除约束"><a href="#5-4-删除约束" class="headerlink" title="5.4 删除约束"></a>5.4 删除约束</h3><p>删除约束很简单，选中一个View，鼠标hover在View的一个约束上时，约束会变红，点按即可删除。</p>
<center>
![](http://ww1.sinaimg.cn/large/afdaace3ly1fnqnhkw90vj215q0yedir.jpg)
</br>
图10 删除一个约束
</center>

<h3 id="5-5-相对于guideline的约束"><a href="#5-5-相对于guideline的约束" class="headerlink" title="5.5 相对于guideline的约束"></a>5.5 相对于guideline的约束</h3><p>除了相对于父布局和兄弟View，ConstraintLayout中还可以在水平方向和垂直方向上添加guide，ConstraintLayout内的View可以添加相对于guideline的约束。</p>
<center>
![](http://ww1.sinaimg.cn/large/afdaace3ly1fnqojv5ddcj20r4072my3.jpg)
</br>
图11 添加guideline
</center>

<p>添加的guideline在xml布局中表现和View一样。guideline可以像View一样添加约束。</p>
<center>
![](http://ww1.sinaimg.cn/large/afdaace3ly1fnqoogvy5jj20rg09ctax.jpg)
</br>
图12 guideline在xml中的表示
</center>

<p>添加完guideline之后，选中guideline，在布局的边缘可以看到一个小三角或者百分号，点击可以切换guideline相对于布局编辑的位置，显示为小三角的方向表示guideline距布局边界的绝对位置（单位是dp），百分号则表示相对位置</p>
<center>
![](http://ww1.sinaimg.cn/large/afdaace3ly1fnqr0whwlmj21ts1acqbo.jpg)
</br>
图13 guideline在屏幕垂直方向上20%的位置，A位于guideline的下方
</center>

<h3 id="5-6-添加相对于View的barrie"><a href="#5-6-添加相对于View的barrie" class="headerlink" title="5.6 添加相对于View的barrie"></a>5.6 添加相对于View的barrie</h3><p>barrier是ConstraintLayout 1.1中新加的特性，barrier和guideline类似，从字面意思可以理解，它相当于一个屏障，包含在其中的View不能越过它的位置。举个例子，图14的布局中，B位于A的右侧，当C位于A的下方，当C的文字比较少时，B会在C的右侧，当C的文字比较多时，C就会被B盖住，但是B左侧的约束又只能有一个。</p>
<center>
![](http://ww1.sinaimg.cn/large/afdaace3ly1fnqt7ah8toj21a8124mzz.jpg)
</br>
图13 C的文字比较少

<p><img src="http://ww1.sinaimg.cn/large/afdaace3ly1fnqtars5vij21aa124n0c.jpg"><br></br><br>图13 C的文字比较多时，B盖住了C</p>
</center>


<p>此时就可以添加一个barrier，在B的左侧添加一个到barrier的约束，使B的位置随着A、C的内容左右移动而不用担心B的内容盖住A。</p>
<center>
![](http://ww1.sinaimg.cn/large/afdaace3ly1fnqt7ah8toj21a8124mzz.jpg)
</br>
图13 C的文字比较少

<p><img src="http://ww1.sinaimg.cn/large/afdaace3ly1fnqtjpiz20j21ae124adv.jpg"><br></br><br>图14 B添加了相对于barrier的约束</p>
</center>

<p>添加barrier的方法：</p>
<blockquote>
<ol>
<li>Click Guidelines <img src="http://ww1.sinaimg.cn/large/afdaace3ly1fnqtmbpbvij200w00w047.jpg">in the toolbar, and then click Add Vertical Barrier or Add Horizontal Barrier.</li>
<li>In the Component Tree window, select the views you want inside the barrier and drag them into the barrier component.</li>
<li>Select the barrier from the Component Tree, open the Attributes window, and then set the barrierDirection.</li>
</ol>
</blockquote>
<ol>
<li>点击工具栏添加guideline的位置，添加垂直或者水平的barrier；</li>
<li>在Component Tree视图中，把想要限制的View拖进barrier中；</li>
<li>在Component Tree中选中barrier，打开右侧的属性窗口，设置barrierDirection属性。</li>
</ol>
<h3 id="5-7-调节约束的位置"><a href="#5-7-调节约束的位置" class="headerlink" title="5.7 调节约束的位置"></a>5.7 调节约束的位置</h3><p>在前面，给View水平方向上添加2个约束时，会发现View自动水平居中了。此时，可以调节ConstraintLayout的bias，使其在屏幕一定比例的位置上，而不是居中。</p>
<center>
![](http://ww1.sinaimg.cn/large/afdaace3ly1fnrnk39ur1g21g80p0x6r.gif)
</br>
图15 调节约束的位置
</center>

<h3 id="5-8-调节View的大小"><a href="#5-8-调节View的大小" class="headerlink" title="5.8 调节View的大小"></a>5.8 调节View的大小</h3><p>ConstraintLayout的子View中，除了可以通过正常的layout_width和layout_height来限制View的宽高为，在Design面板的右侧，可以很方便调整View的大小。</p>
<center>
![](http://ww1.sinaimg.cn/large/afdaace3ly1fnrnm43y7lj20fr0j9jte.jpg)
</br>
图16 调节View的大小
</center>
图中的编号中，

<ol>
<li>调节View的宽高比</li>
<li>删除某个方向上的约束</li>
<li>View的宽高模式，Fixed（宽高写死），Wrap Content，Match Constraints（和match parent一样）</li>
<li>View的margin值</li>
<li>bias</li>
</ol>
<h3 id="5-9-链式线性分组"><a href="#5-9-链式线性分组" class="headerlink" title="5.9 链式线性分组"></a>5.9 链式线性分组</h3><p>在一个链式线性分组内的View会在一个方向上形成一个双向约束，互相约束。</p>
]]></content>
      <categories>
        <category>tech</category>
      </categories>
      <tags>
        <tag>Android</tag>
      </tags>
  </entry>
  <entry>
    <title>Java 8函数式编程–––Lambda表达式</title>
    <url>/2017/11/28/Java-8_Lambda/</url>
    <content><![CDATA[<h2 id="1-介绍"><a href="#1-介绍" class="headerlink" title="1. 介绍"></a>1. 介绍</h2><h3 id="1-1-匿名内部类"><a href="#1-1-匿名内部类" class="headerlink" title="1.1 匿名内部类"></a>1.1 匿名内部类</h3><p>设计匿名内部类的目的，是为了方便开发者将代码作为数据传递。举个栗子，在Android中，为一个按钮设置一个点击事件的监听器：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">button.setOnClickListener(<span class="keyword">new</span> View.OnClickListener() &#123;</span><br><span class="line">     <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onClick</span><span class="params">(View view)</span> </span>&#123;</span><br><span class="line">          Log.v(TAG, <span class="string">&quot;button is clicked!&quot;</span>);</span><br><span class="line">     &#125;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>

<h3 id="1-2-Lambda表达式"><a href="#1-2-Lambda表达式" class="headerlink" title="1.2 Lambda表达式"></a>1.2 Lambda表达式</h3><p>Lambda表达式的作用和匿名内部类相似，也是为了将代码作为数据来传递，从某种意义上讲，Lambda表达式也可以理解为匿名函数，在其他的一些语言中则把称为闭包，实际上意义都差不多的。上面的例子，用Lambda表达式来改写，可以表示为：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">button.setOnClickListener(view -&gt; Log.v(TAG, <span class="string">&quot;button is clicked!&quot;</span>));</span><br></pre></td></tr></table></figure>

<p>和使用匿名内部类传入实现了某个接口的对象不同，Lambda传入的参数是一段代码快，即匿名函数(注意这里已经不在叫方法而叫函数了)。这个匿名函数中，-&gt;将参数和Lambda表达式的主体分开，view是函数的参数，Log.v(TAG, “button is clicked!”)是这个函数的具体实现。</p>
<p><img src="../img/lambda.png" alt="lambda表达式形式"></p>
<p>lambda表达式语法：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">(parameters) -&gt; expression</span><br></pre></td></tr></table></figure>
<p>或者</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">(parameters) -&gt; &#123;statemens;&#125;</span><br></pre></td></tr></table></figure>

<p>Lambda表达式中，参数的类型不需要显式指明，因为javac会根据程序的上下文来推断出参数的类型，这一点和kotlin很相似。</p>
<p>几个Lambda表达式的例子：</p>
<p>1、没有参数</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Runnable runnable = () -&gt; Log.v(TAG, <span class="string">&quot;run&quot;</span>);</span><br><span class="line">``` </span><br><span class="line"><span class="number">2</span>、一个参数</span><br><span class="line"></span><br><span class="line">```java</span><br><span class="line">View.OnClickListener listener = view -&gt; Log.v(TAG, <span class="string">&quot;onClick&quot;</span>);</span><br></pre></td></tr></table></figure>

<p>3、一个参数包含代码块</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Runnable runnable = () -&gt; &#123;</span><br><span class="line">     Log.v(TAG, <span class="string">&quot;run first step&quot;</span>);</span><br><span class="line">     Log.v(TAG, <span class="string">&quot;run second step&quot;</span>);   </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>4、多个参数,不指定参数类型</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Callback&lt;String&gt; callback = (arg1, arg2) -&gt; arg1 + arg2;</span><br></pre></td></tr></table></figure>

<p>5、多个参数指定类型</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Callback&lt;String&gt; callback = (String str1, String str2) -&gt; str1 + str2;</span><br></pre></td></tr></table></figure>

<p>Lambda表达式的参数类型虽然可以由编译器推断出来, 但是在某些情况下, 也可能会推断不出来, 这时候就需要显式声明参数的类型了.</p>
<h3 id="1-3-引用值而非变量"><a href="#1-3-引用值而非变量" class="headerlink" title="1.3 引用值而非变量"></a>1.3 引用值而非变量</h3><p>在匿名内部类中，如果需要引用外部的局部变量，则必须将这个变量设置成final类型，比如</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">final</span> String name = getUserName();</span><br><span class="line">button.setOnClickListener(<span class="keyword">new</span> View.OnClickListener() &#123;</span><br><span class="line">     <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onClick</span><span class="params">()</span> </span>&#123;</span><br><span class="line">          Toast.make(context, <span class="string">&quot;hi, &quot;</span> + name, Toast.LENGTH_LONG).show();</span><br><span class="line">     &#125;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>

<p>为什么匿名内部类访问局部变量必须是final类型的呢？简单来说，是为了保证数值的一致性。局部变量和匿名内部类的生命周期是不一样的，如果匿名内部类直接使用局部变量的引用并修改其值，则有可能造成内外值不一致的情况，所以Java规定了匿名内部类只能引用final类型的局部变量，这样一来，值不会被真正改变，匿名内部类中，也就保证了值的一致性。</p>
<p>在Java 8中，放松了这一限制，可以引用非final类型的变量，然而，该变量在既成事实上也必须是final类型的。</p>
<p>在Lambda表达式中，实际上也只能使用final类型的局部变量，即便不加final关键字，这个变量也还是final类型的。如果试图给Lambda表达式中使用一个非final类型的变量，编译器将会报错。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//这段代码不能通过编译</span></span><br><span class="line">String name = getFirstName();</span><br><span class="line">name = <span class="string">&quot;Mr. &quot;</span> + name;</span><br><span class="line">button.setOnClickListener(view -&gt; Toast.make(context, <span class="string">&quot;Hi, &quot;</span> + name, Toast.LENGTH_LONG).show());</span><br></pre></td></tr></table></figure>

<h2 id="2-Lambda表达式的应用"><a href="#2-Lambda表达式的应用" class="headerlink" title="2 Lambda表达式的应用"></a>2 Lambda表达式的应用</h2><h3 id="2-1-函数式接口"><a href="#2-1-函数式接口" class="headerlink" title="2.1 函数式接口"></a>2.1 函数式接口</h3><p><strong>函数接口（Functional Interface）</strong>是只有一个抽象方法的接口。例如：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">Comparator</span>&lt;<span class="title">T</span>&gt; </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">compare</span><span class="params">(T o1, T o2)</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>及</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">Runnable</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">run</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><em>注意：Java 8中，接口可以有默认方法，即便一个接口定义了多个默认方法，只要它的抽象方法只有一个，它仍然是一个函数式接口。</em></p>
<p>Lambda表达式与函数式接口有什么关系呢？引用书中的一句话：</p>
<blockquote>
<p>Lambda表达式允许你直接以内联的形式为函数式接口的抽象方法提供实现，并把整个表达式作为函数式接口的实例（具体来说，是函数式接口一个具体实现的实例）。</p>
</blockquote>
<p>通俗一点来讲，Lambda表达式为函数式接口提供了具体的实现，从而来实现Java方法的传递（或者说是代码块传递）。当然，匿名内部类也可以实现同样的功能，只不过使用匿名内部类使用起来非常笨拙。</p>
<p>@FunctionalInterface注解用于表示一个接口被设计为了函数式接口。如果自定义的接口加了这个注解，但确不是函数式接口，IDE会在编译时报错，“Multiple non-overriding abstract methods found in interface Foo”，意思是Foo这个接口中有多个抽象方法。</p>
<p>对于函数式接口的设计，@FunctionalInterface并非是必须的，但是加上它是一个好习惯。</p>
<h3 id="2-2-函数描述符"><a href="#2-2-函数描述符" class="headerlink" title="2.2 函数描述符"></a>2.2 函数描述符</h3><p>函数式接口中抽象方法的签名基本上也就是Lambda表达式的签名，我们把这种抽象方法叫做函数描述符。</p>
<p>比如Runnable接口可以看作是一个什么也不接收，什么也不返回的方法的签名，它的run()方法不接收任何参数，最终返回void.</p>
<p>Lambda和函数式接口的方法签名的一种记法：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">() -&gt; <span class="keyword">void</span></span><br></pre></td></tr></table></figure>
<p>这里表示的是Runnable接口所代表的方法。</p>
<p>到此为止，关于Lambda表达式，我们需要记住的是：</p>
<p><strong>1. Lambda表达式可以赋值给一个变量(函数式接口)；</strong></br><br><strong>2. Lambda表达式可以传递给一个接收函数式接口的方法。</strong></p>
<p><strong>例子：</strong><br>Lambda表达式的有效使用方式：</p>
<p>(1) Lambda表达式传给一个接收函数式接口的方法</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">execute(() -&gt; &#123;&#125;);</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">execute</span><span class="params">(Runnable r)</span></span>&#123;</span><br><span class="line">    r.run(); </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这里的Lambda表达式的签名是<code>() -&gt; void</code>，这是Runnable接口所代表的方法。</p>
<p>(2) Lambda表达式作为返回值</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> Callable&lt;String&gt; <span class="title">fetch</span><span class="params">()</span> </span>&#123;</span><br><span class="line">     <span class="keyword">return</span> () -&gt; <span class="string">&quot;Tricky example ;-)&quot;</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">interface</span> <span class="title">Callable</span>&lt;<span class="title">T</span>&gt; </span>&#123;</span><br><span class="line">    <span class="function">T <span class="title">call</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>fetch()方法返回一个Callable<String>对象，Callable<String>所代表的方法是<code>() -&gt; String</code>，这和例中所用的签名是一致的。</p>
<p>(3) 一种错误的用法</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Predicate&lt;Apple&gt; p = (Apple a) -&gt; a.getWeight();</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">interface</span> <span class="title">Predicate</span>&lt;<span class="title">T</span>&gt; </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">boolean</span> <span class="title">test</span><span class="params">(T t)</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>例中Lambda表达式的签名是<code>(Apple) -&gt; Double</code>，Predicate<Apple>所代表的方法是<code>(Apple) -&gt; boolean</code>，不一致。</p>
<h3 id="2-3-函数式接口的使用"><a href="#2-3-函数式接口的使用" class="headerlink" title="2.3 函数式接口的使用"></a>2.3 函数式接口的使用</h3><p>上面介绍了函数式接口和函数描述符的概念，为了应用不同的Lambda表达式，就需要一套能够描述常见函数描述符的函数式接口。Java 8的java.util.function包中为我们引入了很多函数式接口。几个典型的函数式接口如下：</p>
<h4 id="2-3-1-Predicate"><a href="#2-3-1-Predicate" class="headerlink" title="2.3.1 Predicate"></a>2.3.1 Predicate</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@FunctionalInterface</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">Predicate</span>&lt;<span class="title">T</span>&gt;</span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">boolean</span> <span class="title">test</span><span class="params">(T t)</span></span>;</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>涉及到返回值是boolean类型的表达式时，可以用Predicate<T>，例如：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Predicate&lt;String&gt; p = (s) -&gt; !s.isTempty();</span><br></pre></td></tr></table></figure>

<h4 id="2-3-2-Consumer"><a href="#2-3-2-Consumer" class="headerlink" title="2.3.2 Consumer"></a>2.3.2 Consumer</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@FunctionalInterface</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">Consumer</span>&lt;<span class="title">T</span>&gt;</span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">accept</span><span class="params">(T t)</span></span>;</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>需要对一个对象进行访问可以用Consumer<T>，例如：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//定义一个forEach方法</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> &lt;T&gt; forEach(List&lt;T&gt; list, Consumer&lt;T&gt; consumer) &#123;</span><br><span class="line">    <span class="keyword">for</span> (Integer i : list) &#123;</span><br><span class="line">        consumer.consume(i);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//使用</span></span><br><span class="line">forEach(Arrays.asList(<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>), (Integer i) -&gt; System.out.print(i));</span><br></pre></td></tr></table></figure>
<p>2.3.3 Function</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@FunctionalInterface</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">Function</span>&lt;<span class="title">T</span>, <span class="title">R</span>&gt;</span>&#123;</span><br><span class="line">    <span class="function">R <span class="title">apply</span><span class="params">(T t)</span></span>;</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>创建映射关系或者从一个对象中提取信息可以用Function&lt;T, R&gt;。</p>
<h2 id="3-类型检查与类型推断"><a href="#3-类型检查与类型推断" class="headerlink" title="3 类型检查与类型推断"></a>3 类型检查与类型推断</h2><p>上面提到，Lambda表达式为函数式接口提供了实现，但是Lambda表达式本身并不包含实现了哪个函数式接口的任何信息，所以需要了解Lambda表达式的实际类型。</p>
<h3 id="3-1-类型检查"><a href="#3-1-类型检查" class="headerlink" title="3.1 类型检查"></a>3.1 类型检查</h3><p>Lambda表达式需要的类型称为<strong>目标类型</strong>。只要函数签名一致，Lambda表达式可以与很多函数式接口相关联。</p>
<p>一张图说明类型检查的过程：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">List&lt;Apple&gt; heavierThan150g = filter(inventory, (Apple a) -&gt; a.getWeight() &gt; <span class="number">150</span>);</span><br></pre></td></tr></table></figure>

<p><img src="../image/type_check.png" alt="type check"></p>
<h3 id="3-2-类型推断"><a href="#3-2-类型推断" class="headerlink" title="3.2 类型推断"></a>3.2 类型推断</h3><p>类型推断是Java 7引入的概念，&lt;&gt;操作符可使编译器在编译时根据上下文推断出参数类型。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">HashMap&lt;String, Integer&gt; map = <span class="keyword">new</span> HashMap&lt;&gt;();</span><br></pre></td></tr></table></figure>
<p>这里，声明map时，已经明确指定了范型的类型，所以在new出HashMap对象时，编译器已经知道HashMap的具体范型。</p>
<p>Java 8中，Lambda表达式可以省略所有参数的类型。因为函数描述符可以通过目标类型来得到，所以Java编译器就可以通过上下文信息来推断出正确的参数类型，从而确定使用什么函数式接口来配合Lambda表达式。</p>
<p>当然，Lambda表达式也可以不省略参数类型，显式指定。至于这两种方式哪一种更好呢，则取决于不同的场景，有时候省略参数类型代码更易读，有的时候显式指明参数类型则比较好。</p>
<h2 id="4-方法引用"><a href="#4-方法引用" class="headerlink" title="4 方法引用"></a>4 方法引用</h2><h3 id="4-1-方法引用简介"><a href="#4-1-方法引用简介" class="headerlink" title="4.1 方法引用简介"></a>4.1 方法引用简介</h3><p>既然Lambda表达式可以与函数式接口相关联，作为函数式接口的函数描述符的引用，那么一个对象的方法有没有类似的表示方法呢？答案是有的，Java 8提供了方法引用(Method Referen)的表示方法。（在C语言或者是其他一些编程语言中，也有类似的概念，比如，C语言中的指向函数的指针，Python中把一个函数赋值给变量）</p>
<p>方法引用可以重复使用现有的方法定义，并像Lambda表达式一样传递它们。</p>
<p>方法引用通过一个::来表示，需要使用方法引用时，目标引用放在分隔符::前，方法名放在后面。</p>
<p>一些例子：</p>
<table>
<thead>
<tr>
<th>Lambda</th>
<th>方法引用</th>
</tr>
</thead>
<tbody><tr>
<td>() -&gt; Thread.currentThread().dumpStack()</td>
<td>Thread.currentThread()::dumpStack</td>
</tr>
<tr>
<td>(str, i) -&gt; str.substring(i)</td>
<td>String::substring</td>
</tr>
<tr>
<td>(String s) -&gt; System.out.print(s)</td>
<td>System.out::print</td>
</tr>
</tbody></table>
<h3 id="4-2-构建方法引用"><a href="#4-2-构建方法引用" class="headerlink" title="4.2 构建方法引用"></a>4.2 构建方法引用</h3><h4 id="4-2-1-方法引用主要分为3类："><a href="#4-2-1-方法引用主要分为3类：" class="headerlink" title="4.2.1 方法引用主要分为3类："></a>4.2.1 方法引用主要分为3类：</h4><ol>
<li><p>指向静态方法引用</p>
<p> 例如Integer.parseInt()方法，写作Integer::parseInt</p>
</li>
<li><p>指向任意类型方法实例的方法引用</p>
<p> 如String中的length方法，写作String::length</p>
</li>
<li><p>指向已有对象的实例方法的方法引用</p>
<p> 比如有一个Student的实例stu，有一个方法是getName，就可以写成stu::getName</p>
</li>
</ol>
<p><strong>区别：</strong></p>
<p>静态方法引用是直接引用类的静态方法，通过 “类名::方法名”的方式引用；</p>
<p>第二种方法引用中，引用了一个对象的方法，但是这个对象本身是Lambda表达式的一个参数，不如上面的例子中，对应的Lambda表达式是(String s) -&gt; s.length()；</p>
<p>第三种中，是在Lambda表达式中调用一个已经存在的对象的方法，上面的例子改写成Lambda表达式就是() -&gt; stu.getName()，和第二种的区别就是调用的对象的方法不是Lambda的参数。</p>
<h4 id="4-1-2-构造方法引用"><a href="#4-1-2-构造方法引用" class="headerlink" title="4.1.2 构造方法引用"></a>4.1.2 构造方法引用</h4><p>对于一个现有的构造方法，可以利用它的名称和关键字new来创建一个方法引用：ClassName::new.</p>
<p>它的功能和静态方法的引用类似，比如有一个无参构造方法，适合Supplier的签名，() -&gt; Apple，那么可以这样写：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Supplier&lt;Apple&gt; constuctor = Apple::<span class="keyword">new</span>;</span><br><span class="line">Apple apple = constructor.get();</span><br></pre></td></tr></table></figure>

<p>它等价于Lambda表达式的写法：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Supplier&lt;Apple&gt; constuctor = () -&gt; <span class="keyword">new</span> Apple();</span><br><span class="line">Apple apple = constructor.get();</span><br></pre></td></tr></table></figure>

<h2 id="5-实践"><a href="#5-实践" class="headerlink" title="5 实践"></a>5 实践</h2><p>有一些菜品，存在<code>List&lt;Dish&gt; dishes</code>中，现在要将它们按照价格升序排序。</p>
<ol>
<li><p>在Java 8之前</p>
<p> Java 8之前，List没有sort方法，需要借助Collection类。</p>
 <figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">DishComparator</span> <span class="keyword">implements</span> <span class="title">Comparator</span>&lt;<span class="title">Dish</span>&gt; </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">compare</span><span class="params">(Dish d1, Dish d2)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> d1.getPrice() - d2.getPrice();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">Collection.sort(list, <span class="keyword">new</span> DishComparator());</span><br></pre></td></tr></table></figure>
</li>
<li><p>Java 8中，使用来排序list</p>
<p> Java 8之前，List没有sort方法，需要借助Collection类。</p>
 <figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">DishComparator</span> <span class="keyword">implements</span> <span class="title">Comparator</span>&lt;<span class="title">Dish</span>&gt; </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">compare</span><span class="params">(Dish d1, Dish d2)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> d1.getPrice() - d2.getPrice();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">list.sort(<span class="keyword">new</span> DishComparator());</span><br></pre></td></tr></table></figure>
</li>
<li><p>使用匿名内部类</p>
 <figure class="highlight java"><table><tr><td class="code"><pre><span class="line">list.sort(<span class="keyword">new</span> Comparator&lt;Dish&gt; &#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">compare</span><span class="params">(Dish d1, Dish d2)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> d1.getPrice() - d2.getPrice();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>
</li>
<li><p>使用Lambda表达式</p>
 <figure class="highlight java"><table><tr><td class="code"><pre><span class="line">list.sort((Dish d1, Dish d2) -&gt; d1.getPrice() - d2.getPrice());</span><br></pre></td></tr></table></figure>
</li>
<li><p>使用方法引用</p>
 <figure class="highlight java"><table><tr><td class="code"><pre><span class="line">list.sort(Comparator.comparating(Dish::getPrice))</span><br></pre></td></tr></table></figure>

</li>
</ol>
<h2 id="6-小结"><a href="#6-小结" class="headerlink" title="6 小结"></a>6 小结</h2><ul>
<li><strong>Lambda表达式</strong>可以理解为一种匿名函数：没有名称，但有参数列表、函数主体、返回值；</li>
<li>Lambda表达式可以让你更简洁的传递代码；</li>
<li><strong>函数式接口</strong>就是仅仅声明了一个抽象方法的接口；</li>
<li>只有在接收函数式接口的地方才可以使用Lambda表达式；</li>
<li>Lambda表达式允许你直接内联，为函数式接口的抽象方法提供实现，并且将整个表达式作为函数式接口的的一个实例；</li>
<li>Java 8自带一些常用的函数式接口，在java.util.function包里，包括Predicate<T>、Function&lt;T,R&gt;、Supplier<T>、Consumer<T>等；</li>
<li>Lambda表达式所需要的代表的类型成为目标类型；</li>
<li>方法引用让你重复使用现有的方法实现并直接传递它们；</li>
<li>Comparator、Predicate、和Function等函数式接口有几个可以结合Lambda表达式的默认方法。</li>
</ul>
<p>–</p>
<p>作者：Ivan J. Lee</br><br>时间：2017-11-28 00:40</p>
]]></content>
      <categories>
        <category>tech</category>
      </categories>
      <tags>
        <tag>java</tag>
      </tags>
  </entry>
  <entry>
    <title>Kotlin中的数字类型的相等性</title>
    <url>/2019/02/27/Kotlin-Numbers-Equality/</url>
    <content><![CDATA[<h2 id="相等性"><a href="#相等性" class="headerlink" title="相等性"></a>相等性</h2><h3 id="相等性分类"><a href="#相等性分类" class="headerlink" title="相等性分类"></a>相等性分类</h3><p>Kotlin中有2种相等性  </p>
<ul>
<li>结构型相等(==)</li>
<li>引用型相等(===)</li>
</ul>
<p>可以理解为结构型相等是值比较，和Java中的equals类似，引用型相等是通过比较引用指向的对象是否为同一个，和Java中的==类似。</p>
<p>Kotlin中，结构性相等使用双等号==来表示（否定形式是!=），引用型相等使用恒等号===表示（否定形式是!==）。</p>
<figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"><span class="keyword">open</span> <span class="keyword">operator</span> <span class="function"><span class="keyword">fun</span> <span class="title">equals</span><span class="params">(other: <span class="type">Any</span>?)</span></span>: <span class="built_in">Boolean</span></span><br></pre></td></tr></table></figure>
<p>kotlin中，Any类重载了==操作符， 但是a==b却不完全等价于a.equlas(b)。</p>
<figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">equals</span><span class="params">()</span></span> &#123;</span><br><span class="line">    <span class="keyword">val</span> n : <span class="built_in">Int</span> = <span class="number">123</span></span><br><span class="line">    <span class="keyword">val</span> m : <span class="built_in">Int</span> = <span class="number">3</span></span><br><span class="line"></span><br><span class="line">    n.equals(m)</span><br><span class="line">    m == n</span><br><span class="line"></span><br><span class="line">    <span class="keyword">val</span> p: <span class="built_in">Int</span>? = <span class="literal">null</span></span><br><span class="line">    <span class="keyword">val</span> q: <span class="built_in">Int</span>? = <span class="number">3</span></span><br><span class="line">    <span class="keyword">val</span> s = <span class="string">&quot;123&quot;</span></span><br><span class="line">    </span><br><span class="line">    p == q</span><br><span class="line">    p == n</span><br><span class="line">    p == s   <span class="comment">//Operator &#x27;==&#x27; cannot be applied to &#x27;Int?&#x27; and &#x27;String&#x27;</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title">equals</span><span class="params">()</span> </span>&#123;</span><br><span class="line">      <span class="keyword">int</span> n = <span class="number">123</span>;</span><br><span class="line">      <span class="keyword">int</span> m = <span class="number">3</span>;</span><br><span class="line">      Integer.valueOf(n).equals(Integer.valueOf(m));</span><br><span class="line">      Integer p = (Integer)<span class="keyword">null</span>;</span><br><span class="line">      Integer q = <span class="number">3</span>;</span><br><span class="line">      Intrinsics.areEqual(p, q);</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure>

<p>根据变量类型不同，==会被编译成不同类型</p>
<ul>
<li>变量为非空类型，a==b被编译成a.equals(b)</li>
<li>变量未可空类型，a==b被编译成Intrinsics.areEqual(p, q)</li>
<li>==两侧类型不同，编译失败</li>
</ul>
<p>其中Intrinscs.areEquals(Object, Object)中对参数都进行了判空，所以在kotlin中，只要能编译通过，请放心大胆的使用==，不用担心空指针的问题。</p>
<figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> static boolean areEqual(Object first, Object second) &#123;</span><br><span class="line">       <span class="keyword">return</span> first == <span class="literal">null</span> ? second == <span class="literal">null</span> : first.equals(second);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="数字类型的相等性"><a href="#数字类型的相等性" class="headerlink" title="数字类型的相等性"></a>数字类型的相等性</h3><p>在Kotlin中，数字“基本类型”一共有6种，分别是Byte、Short、Int、Long、Float、Double，这6种类型都继承自Number类。</p>
<p>从形式上看，这6种类型和Java中的包装数字类型相同，但是他们和Java中的数字类型不完全等价。</p>
<p>kotlin中，被声明成可空类型(Int?等)的数字变量在JVM中会被表示成包装类型数字，被声明成非空类型的数字在JVM中可以被表示基本类型数字。</p>
<h4 id="整数的相等性"><a href="#整数的相等性" class="headerlink" title="整数的相等性"></a>整数的相等性</h4><figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">primitive</span><span class="params">()</span></span> &#123;</span><br><span class="line">    <span class="keyword">val</span> a: <span class="built_in">Int</span> = <span class="number">128</span></span><br><span class="line">    println(a == a) <span class="comment">// 1</span></span><br><span class="line">    <span class="keyword">val</span> primitiveA: <span class="built_in">Int</span> = a</span><br><span class="line">    println(a === primitiveA) <span class="comment">// 2</span></span><br><span class="line">    <span class="keyword">val</span> boxedA: <span class="built_in">Int</span>? = a</span><br><span class="line">    <span class="keyword">val</span> anotherBoxedA: <span class="built_in">Int</span>? = a</span><br><span class="line">    println(boxedA === primitiveA)<span class="comment">// 3</span></span><br><span class="line">    println(boxedA === anotherBoxedA)<span class="comment">// 4</span></span><br><span class="line">    println(boxedA == primitiveA)<span class="comment">// 5</span></span><br><span class="line">    println(boxedA == anotherBoxedA)<span class="comment">//6</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在这段代码中，注释1～5中的打印结果分别对应：</p>
<p><strong>1、数字类型始终和自身相等</strong></p>
<p>a为非空变量，所以a为基本类型，无论是a==a，还是a===a都是true.</p>
<p><strong>2、基本类型整数，值相等即满足结构型相等和引用型相等</strong></p>
<p>a和primitiveA都是非空变量，都被存储为基本类型，只要它们的值相等，无论是==还是===，比较的结果都是true.</p>
<p><strong>3、装箱类型，即便是值相等，只要类型不同，则不满足引用型相等</strong></p>
<p>由于被声明成了可空变量，boxedA被存储为装箱类型，primitiveA是非空变量，被存储为基本类型，装箱类型和基本类型相比，类型不同，所以不满足引用型相等，boxedA === primitiveA为false.</p>
<p><strong>4、装箱类型，即使值相等，只要引用不指向同一个对象，不满足引用型相等</strong></p>
<p>boxedA和anotherBoxedA都是可空变量，都被存储为装箱类型，值都是128，赋值操作会创建出不同的Int对象，所以不满足引用型相等，boxedA === anotherBoxedA值为false.</p>
<p>Kotlin在处理整数的时候，和Java中的Integer一样，0到127都有缓存池，数值小于128时，取到的是同一个对象，大于127则会创建新的对象。所以在上述代码块中，a的值是128，创建了不同的对象，使用===比较，值为false. 将上述代码中a的值改成126，取到的都是缓存池中的对象，因此，即使使用===比较，值也是true.</p>
<p><strong>5、值相等的数字，满足结构型相等</strong></p>
<p>在注释5和6中，primitiveA，boxedA，anotherBoxedA值都是128，primitiveA是基本类型，boxedA和anotherBoxedA是装箱类型，使用==比较，只比较它们的值，都相等，都满足结构型相等。</p>
<h4 id="浮点数的相等性"><a href="#浮点数的相等性" class="headerlink" title="浮点数的相等性"></a>浮点数的相等性</h4><p>对于浮点数的比较</p>
<ul>
<li>相等性检测：a == b 与 a != b</li>
<li>比较操作符：a &lt; b、 a &gt; b、 a &lt;= b、 a &gt;= b</li>
<li>区间实例以及区间检测：a..b、 x in a..b、 x !in a..b</li>
</ul>
<p>当其中的操作数 a 与 b 都是明确的（可空或非空的）Float 或 Double 类型时，该检测遵循 IEEE 754 浮点数运算标准。</p>
<p>否则会使用不符合该标准的结构相等性检测，这会导致 NaN 等于其自身，而 -0.0 不等于 0.0。<br>然而，为了支持泛型场景并提供全序支持，当这些操作数并非静态类型为浮点数（例如是 Any、 Comparable&lt;……&gt;、 类型参数）时，这些操作使用为 Float 与 Double 实现的不符合标准的 equals 与 compareTo，这会出现：</p>
<ul>
<li>认为 NaN 与其自身相等</li>
<li>认为 NaN 比包括正无穷大（POSITIVE_INFINITY）在内的任何其他元素都大</li>
<li>认为 -0.0 小于 0.0</li>
</ul>
<p>IEEE 754中对于浮点数比较的定义</p>
<blockquote>
<p> <strong>浮点数的比较</strong></p>
<p>浮点数基本上可以按照符号位、指数域、尾数域的顺序作字典比较。显然，所有正数大于负数；正负号相同时，指数的二进制表示法更大的其浮点数值更大。</p>
<p> <strong>标准运算</strong></p>
<p> 下述函数必须提供:</p>
<p>……</p>
<ul>
<li>比较运算. -Inf &lt;负的规约浮点数数&lt;负的非规约浮点数&lt; -0.0 = 0.0 &lt;正的非规约浮点数&lt;正的规约浮点数&lt; Inf；</li>
<li>特殊比较： -Inf = -Inf, Inf = Inf, NaN与任何浮点数（包括自身）的比较结果都为假，即 (NaN ≠ x) = false.</li>
</ul>
</blockquote>
<figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">stdFloatNumbers</span><span class="params">()</span></span> &#123;</span><br><span class="line">    <span class="comment">// standard</span></span><br><span class="line">    println(<span class="built_in">Float</span>.NaN == <span class="built_in">Float</span>.NaN) <span class="comment">//false</span></span><br><span class="line"></span><br><span class="line">    println(<span class="built_in">Float</span>.NaN &gt; <span class="built_in">Float</span>.POSITIVE_INFINITY) <span class="comment">//false</span></span><br><span class="line">    println(<span class="built_in">Float</span>.NaN &lt; <span class="built_in">Float</span>.POSITIVE_INFINITY) <span class="comment">//false</span></span><br><span class="line"></span><br><span class="line">    println(<span class="built_in">Float</span>.NaN &lt; <span class="built_in">Float</span>.NEGATIVE_INFINITY) <span class="comment">//false</span></span><br><span class="line">    println(<span class="built_in">Float</span>.NaN &gt; <span class="built_in">Float</span>.NEGATIVE_INFINITY) <span class="comment">//false</span></span><br><span class="line"></span><br><span class="line">    println(-<span class="number">0.0</span> == <span class="number">0.0</span>) <span class="comment">//true</span></span><br><span class="line">    println(-<span class="number">0.0</span> &lt; <span class="number">0.0</span>)  <span class="comment">//false</span></span><br><span class="line">    <span class="keyword">val</span> f0 : <span class="built_in">Float</span> = <span class="built_in">Float</span>.NaN</span><br><span class="line">    println(f0 == f0) <span class="comment">//false</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">floatNumbers</span><span class="params">()</span></span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">val</span> f1 : Comparable&lt;<span class="built_in">Float</span>&gt; = <span class="built_in">Float</span>.NaN</span><br><span class="line">    <span class="keyword">val</span> f2 : Comparable&lt;<span class="built_in">Float</span>&gt; = <span class="built_in">Float</span>.NaN</span><br><span class="line">    <span class="keyword">val</span> f3 : Any = <span class="built_in">Float</span>.NaN</span><br><span class="line">    <span class="keyword">val</span> f4 : Any? = <span class="built_in">Float</span>.NaN</span><br><span class="line">    <span class="keyword">val</span> f5 : Comparable&lt;<span class="built_in">Double</span>&gt; = -<span class="number">0.0</span></span><br><span class="line">    <span class="keyword">val</span> f6 : Comparable&lt;<span class="built_in">Double</span>&gt; = <span class="number">0.0</span></span><br><span class="line">    <span class="keyword">val</span> pInf = <span class="built_in">Float</span>.POSITIVE_INFINITY</span><br><span class="line"></span><br><span class="line">    <span class="comment">// NaN not equals NaN</span></span><br><span class="line">    println(f1 == f1) <span class="comment">//true</span></span><br><span class="line">    println(f1 == f2) <span class="comment">//true</span></span><br><span class="line">    println(f1 == f3) <span class="comment">//true</span></span><br><span class="line">    println(f3 == f4) <span class="comment">//true</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// -0.0 not equals 0.0</span></span><br><span class="line">    println(f5 == f6) <span class="comment">//fasle</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
]]></content>
      <tags>
        <tag>Kotlin</tag>
      </tags>
  </entry>
  <entry>
    <title>Welcome</title>
    <url>/2017/06/08/first_page/</url>
    <content><![CDATA[<p>Welcome</p>
<p><a href="about/index.html">About Me</a></p>
]]></content>
      <categories>
        <category>other</category>
      </categories>
      <tags>
        <tag>other</tag>
        <tag>test</tag>
      </tags>
  </entry>
  <entry>
    <title>Git常用命令</title>
    <url>/2017/06/08/git/</url>
    <content><![CDATA[<p><em>本文出处<a href="https://zhuanlan.zhihu.com/p/25415162">https://zhuanlan.zhihu.com/p/25415162</a> 或者 <a href="http://blog.csdn.net/u013301192/article/details/69568557">http://blog.csdn.net/u013301192/article/details/69568557</a></em></p>
<p>Git作为一种常用的现代版本管理工具，应用的十分广泛，作为开发者，Git是一项必不可少的技能，掌握常见的Git命令能够大大提高我们的工作效率。</p>
<p>这里只介绍最基础的，最常用的命令，配置相关的东西直接略过，git相关的一些概念也不介绍了。在执行下面的命令的时候，假定你已经安装好了git，并且在你的远程git仓库的网站上添加了你的key，建立了安全的连接。以下所有的命令基于Mac OS X 10.12，Git版本2.10.1 (Apple Git-78)。</p>
<h3 id="基本命令"><a href="#基本命令" class="headerlink" title="基本命令"></a>基本命令</h3><h4 id="下载项目"><a href="#下载项目" class="headerlink" title="下载项目"></a>下载项目</h4><p>拿到项目的git地址，比如这个<a href="mailto:&#x67;&#x69;&#116;&#64;&#x67;&#105;&#x74;&#104;&#x75;&#x62;&#x2e;&#99;&#x6f;&#x6d;">&#x67;&#x69;&#116;&#64;&#x67;&#105;&#x74;&#104;&#x75;&#x62;&#x2e;&#99;&#x6f;&#x6d;</a>:IvanJLee/git.git，新建一个文件夹，把代码下载下来：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">mkdir LearningGit</span><br><span class="line">cd LearningGit</span><br><span class="line">git clone git@github.com:IvanJLee&#x2F;git.git</span><br></pre></td></tr></table></figure>

<p>等待代码下载完成，LearningGit目录下，多出了一个git文件夹，这个文件夹中就是上面那个仓库的所有文件了。进入git文件夹，查看所有文件，会发现有一个.git文件夹，这就是Git的版本库了。</p>
<p>有时候是在本地新建的项目，想上传到远程的仓库，在项目的根目录下，初始化git仓库：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">git init</span><br></pre></td></tr></table></figure>

<p>查看远程仓库：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">git remote -v</span><br></pre></td></tr></table></figure>

<p>添加一个远程仓库：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">git remote add origin-name git@github.com:IvanJLee&#x2F;git.git</span><br></pre></td></tr></table></figure>

<h4 id="个人信息的配置"><a href="#个人信息的配置" class="headerlink" title="个人信息的配置"></a>个人信息的配置</h4><p>一般一个项目，提交代码的时候都会提前配置好个人信息，以便查看提交的作者信息。没有配置的时候，名字默认是取的是操作系统的当前用户的名字。</p>
<p>查看配置信息：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">git config --list</span><br></pre></td></tr></table></figure>

<p>设置用户名和邮箱（全局的配置加上–global，只是当前项目的话，就不要了，这里一般当前项目没有配的话，就用的是全局的配置。为什么要有两个呢，比如有这样的场景，我的笔记本是公司给配的 ，git的全局配置是真名和公司邮箱，但有时候，我会写一些自己的代码，上传到GitHub上，用的是我的昵称和私人邮箱，所以个人的项目就进行单独的配置）：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">git config (--global) user.name &quot;Ivan&quot;</span><br><span class="line">git config (--global) user.mail &quot;lijundut@foxmail.com&quot;</span><br></pre></td></tr></table></figure>

<p>当然修改配置除了上述方法之外，还可以直接改配置文件，可以改的很多，绝对不止用户名和邮箱，修改当前项目的配置的话直接编辑.git/config文件；修改当前用户的配置，编辑~/.gitconfig；修改整个操作系统的配置，编辑/etc/gitconfig.</p>
<h4 id="提交代码"><a href="#提交代码" class="headerlink" title="提交代码"></a>提交代码</h4><p>对项目中的文件作出修改或删除，或者新建文件之后，查看哪些文件有修改：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">git status</span><br></pre></td></tr></table></figure>
<p><img src="https://pic3.zhimg.com/v2-b90a8993bb2181b3699f02dc808e13ca_b.png" alt="这里写图片描述"><br>Changes not staged for commit是对项目中已有的文件作出的修改，Untracked files是新建的文件，尚未加到版本库中。</p>
<p>查看具体有哪些修改，查看全部文件的：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">git diff</span><br></pre></td></tr></table></figure>

<p>或者，查看单个文件：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">git diff README.md</span><br></pre></td></tr></table></figure>

<p>将需要提交的文件加到待提交列表（支持正则表达式），比如把README.md加进去：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">git add README.md</span><br></pre></td></tr></table></figure>

<p>或者把所有修改过的文件全部加进去：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">git add *</span><br></pre></td></tr></table></figure>

<p>提交修改到本地暂存区：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">git commit -m &#39;my commit message&#39;</span><br></pre></td></tr></table></figure>

<p>或者，使用其它的文本编辑器编辑提交信息（输完下面的命令后，会自动跳过去，Mac OX的终端中默认用vim）：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">git commit</span><br></pre></td></tr></table></figure>

<p>提交修改到远程分支（这时候可能别人已经修改了代码，你的push会被拒绝，先pull一下就可以了）：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">git push</span><br></pre></td></tr></table></figure>

<p>获取远程的修改<br>Git是协同工作的工具，我们自己在修改的同时，别人也在修改，那么获取别人的修改就有了一下的命令。</p>
<p>获取远程仓库的修改：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">git fetch</span><br></pre></td></tr></table></figure>

<p>获取远程仓库的修改，并合并到本地分支：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">git pull</span><br></pre></td></tr></table></figure>

<p>有多个远程仓库的话：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">git pull origin1</span><br><span class="line">git pull origin2</span><br></pre></td></tr></table></figure>

<p>简单来说，pull = fetch + merge，详细区别请看git pull与fetch的区别</p>
<h4 id="分支管理"><a href="#分支管理" class="headerlink" title="分支管理"></a>分支管理</h4><p>一般来说，刚拉下来的项目代码都是在master分支上，绝大多数情况下，master分支是受保护的分支，不允许直接提交代码，这也是我们在使用Git时应当注意的。master分支在任何情况下都是禁止直接提交代码的。</p>
<p>查看本地分支：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">git branch</span><br></pre></td></tr></table></figure>

<p>查看远程分支：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">git branch -r</span><br></pre></td></tr></table></figure>

<p>查看全部分支：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">git branch -a</span><br></pre></td></tr></table></figure>

<p>基于当前所在的本地分支创建一个新分支（比如当前在master分支，执行下面的命令后切到了my-develop分支，但在my-develop分支上push代码到远程仓库仍然是提交到master分支上的）：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">git checkout -b my-develop</span><br></pre></td></tr></table></figure>

<p>基于远程分支创建一个新分支（也是创建一个新的分支，但是和上面不同的是，在my-branch上push代码会提交到远程的develop分支上）：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">git checkout -b origin&#x2F;develop my-branch</span><br></pre></td></tr></table></figure>

<p>切换到本地的另外一个分支上，比如develop-ivan（如果这个分支不存在，会报错，加上参数-b创建新的分支）：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">git checkout develop-ivan</span><br></pre></td></tr></table></figure>

<p>给分支改名：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">git branch -m old-branch-name new-branch-name</span><br></pre></td></tr></table></figure>

<p>把本地分支提交到远程仓库：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">git push origin -u local-branch-name:remote-branch-name</span><br></pre></td></tr></table></figure>

<p>上面的一条命令等同于下面的两条命令：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">git push origin local-branch-name:remote-branch-name</span><br><span class="line">git branch --set-upstream-to&#x3D;origin&#x2F;remote-branch-name local-branch-name</span><br></pre></td></tr></table></figure>

<p>删除一个本地分支，比如删除my-branch分支：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">git branch -d my-branch</span><br></pre></td></tr></table></figure>

<p>如果本地有commit，无法删除，删除本地本地分支以及此分支上的commit：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">git branch -D my-branch</span><br></pre></td></tr></table></figure>

<p>删除一个远程分支，比如develop-lee分支(没有直接删除远程分支的命令，使用push命令，本地分支名为空就可以了)：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">git push origin :develop</span><br></pre></td></tr></table></figure>

<p>合并其他分支的代码到当前分支：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">git merge other-branch-name</span><br></pre></td></tr></table></figure>

<p>或：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">git rebase other-branch-name</span><br></pre></td></tr></table></figure>

<p>merge和rebase的功能基本相似，都是合并代码，区别是rebase会把git提交的时间线压平，提交的时间线看起来会更加整洁，但是不建议这么做，一般建议使用merge。git中merge和rebase的区别<br>查看提交信息<br>查看当前分支的commit信息：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">git log</span><br></pre></td></tr></table></figure>

<p>查看每次commit修改的文件：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">git log --stat</span><br></pre></td></tr></table></figure>

<p>按关键字筛选commit信息：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">git log -S keyword</span><br></pre></td></tr></table></figure>

<p>按作者筛选commit信息，支持正则：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">git log --author &#x3D; &quot;Ivan&quot;</span><br></pre></td></tr></table></figure>

<h4 id="暂存代码"><a href="#暂存代码" class="headerlink" title="暂存代码"></a>暂存代码</h4><p>有时候，正在自己的分支上开发，突然出现了线上bug，需要去其他分支修复，当前的分支功能又没有开发完毕，你还不想提交未完成的代码，这时候使用stash命令就会很方便。stash命令可以把修改的代码都存在本地，而不commit，之后回来可以恢复之前的修改。常用的stash命令如下：</p>
<p>查看保存的修改：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">git stash list</span><br></pre></td></tr></table></figure>

<p>查看某一个stash修改的具体内容：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">git stash show -p stash@&#123;1&#125;</span><br></pre></td></tr></table></figure>

<p>查看某一个stash修改的文件：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">git stash show stash@&#123;0&#125;</span><br></pre></td></tr></table></figure>

<p>保存当前的修改：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">git stash save &quot;save message&quot;</span><br></pre></td></tr></table></figure>

<p>或者，自动填写stash message：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">git stash</span><br></pre></td></tr></table></figure>

<p>删除某一次stash：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">git stash drop stash@&#123;1&#125;</span><br></pre></td></tr></table></figure>

<p>或者删除最近的一次stash：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">git stash drop</span><br></pre></td></tr></table></figure>

<p>恢复最近一次stash：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">git stash pop</span><br></pre></td></tr></table></figure>

<p>恢复某一次stash：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">git stash pop stash@&#123;1&#125;</span><br></pre></td></tr></table></figure>

<p>删除全部的stash：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">git stash clear</span><br></pre></td></tr></table></figure>

<h4 id="其他常见命令"><a href="#其他常见命令" class="headerlink" title="其他常见命令"></a>其他常见命令</h4><p>恢复一个文件的修改（和切换分支一样，也是checkout）:</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">git checkout file_name</span><br></pre></td></tr></table></figure>

<p>把提交的文件回滚到某一次提交（先用git log查看提交记录，找到某次提交的sha1值，使用git  reset回到某次提交，其中soft表示保留新的修改但取消git add，mixed表示保留修改和git add，hard表示不保留修改）：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">git log</span><br><span class="line">git reset --(soft|mixed|hard) 3275a0c85fb2fbbcd6eaa65be1f956d27fa9998b</span><br></pre></td></tr></table></figure>

<p>使用git add命令，把文件加到要提交的列表中后，把它待提交列表中移除：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">git reset --HEAD filename</span><br></pre></td></tr></table></figure>

<p>把一个文件从版本库中移除：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">git rm filename</span><br></pre></td></tr></table></figure>

<h3 id="更多应用"><a href="#更多应用" class="headerlink" title="更多应用"></a>更多应用</h3><p>以上只是Git使用的最基本命令，掌握这些命令，工作中Git操作大部分已经没有问题。当然，Git的功能是很强大的，所能做的事情也远远不止这些，要全面掌握Git的技巧，一两篇文章是说不清楚的。当然，熟悉Git最好的方法就是去实践，学以致用，用的多了自然就记得住。</p>
<p>查看所有的Git命令，可以详细了解每一条命令以及加参数的用法：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">git --help</span><br></pre></td></tr></table></figure>

<p>要想系统学习Git，可以找到的资源有很多，下面是一些学习Git的不错的网站。</p>
<p>Pro git: <a href="https://git-scm.com/">git–distributed-is-the-new-centralized</a>，简体中文版：<a href="https://git-scm.com/book/zh/v2">Pro Git</a></p>
<p><a href="http://www.liaoxuefeng.com/wiki/0013739516305929606dd18361248578c67b8067c8c017b000">廖雪峰的Git教程</a></p>
<p><a href="http://learngitbranching.js.org/">learngitbranching以游戏的方式学习Git</a></p>
]]></content>
      <categories>
        <category>tools</category>
      </categories>
      <tags>
        <tag>git</tag>
      </tags>
  </entry>
  <entry>
    <title>Java 8函数式数据处理</title>
    <url>/2017/12/27/Java-8_Stream/</url>
    <content><![CDATA[<h1 id="1-流"><a href="#1-流" class="headerlink" title="1 流"></a>1 流</h1><h2 id="1-1-流是什么"><a href="#1-1-流是什么" class="headerlink" title="1.1 流是什么"></a>1.1 流是什么</h2><p><strong>流</strong>是Java 8中新引入的概念，它允许你以声明式方式处理数据集合（通过查询语句来表达，而不是临时编写一个实现）。</p>
<p>举个例子，筛选出价格大于¥50的菜品，并对这些菜品进行排序，最后返回菜品名称的集合，在Java 8之前：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//第一步，筛选</span></span><br><span class="line">List&lt;Dish&gt; tempList = <span class="keyword">new</span> ArrayList&lt;&gt;(dishes.size());</span><br><span class="line"><span class="keyword">for</span> (Dish dish : dishes) &#123;</span><br><span class="line">    <span class="keyword">if</span> (dish.getPriceCent() &gt; <span class="number">5000</span>) &#123;</span><br><span class="line">        tempList.add(dish);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//第二步，排序</span></span><br><span class="line">Collections.sort(tempList, <span class="keyword">new</span> Comparator&lt;Dish&gt;() &#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">compare</span><span class="params">(Dish d1, Dish d2)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> d1.getPriceCent() - d2.getPriceCent();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;);</span><br><span class="line"><span class="comment">//第三步，返回名称集合</span></span><br><span class="line">List&lt;String&gt; result = <span class="keyword">new</span> ArrayList&lt;&gt;(tempList.size())</span><br><span class="line"><span class="keyword">for</span> (Dish dish : tempList) &#123;</span><br><span class="line">    result.add(dish.getName());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>在Java 8中，引入了流的概念之后，结合Lambda表达式：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">List&lt;String&gt; result = dishes.stream()</span><br><span class="line">                            .filter(dish -&gt; dish.getPriceCent() &gt; <span class="number">5000</span>)</span><br><span class="line">                            .sorted(comparing(Dish::getPriceCent))</span><br><span class="line">                            .map(Dish::getName)</span><br><span class="line">                            .collect(toList());</span><br></pre></td></tr></table></figure>

<p>流式方法的好处：</p>
<ul>
<li>代码是以声明性方式写的，说明想要完成什么，而不是如何实现一个操作；</li>
<li>把几个基本操作链接起来，用以表达复杂的数据操作流水线，使代码清晰可读。</li>
</ul>
<p>使用Java 8的Stream API可以写出这样的代码：</p>
<ul>
<li>声明性——更简洁 ，更易读</li>
<li>可复合——更灵活</li>
<li>可并行——性能更好</li>
</ul>
<h2 id="1-2-流简介"><a href="#1-2-流简介" class="headerlink" title="1.2 流简介"></a>1.2 流简介</h2><h3 id="1-2-1-概念和术语"><a href="#1-2-1-概念和术语" class="headerlink" title="1.2.1 概念和术语"></a>1.2.1 概念和术语</h3><p>Java 8中的集合支持一个新的stream方法，它会返回一个流，当然也有很多其他方法，比如利用数值范围或者I/O资源也可以生成流元素。</p>
<p>定义：<strong>从支持数据处理操作的源生成得元素序列。</strong></p>
<p>关键概念：</p>
<table>
<thead>
<tr>
<th>术语</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td>元素序列</td>
<td>类似集合，流提供一个接口，可以访问特定元素类型的一组有序值。集合讲的是数据，流讲的是计算。</td>
</tr>
<tr>
<td>源</td>
<td>流会使用一个提供数据的源，比如集合、数组或者是I/O. 从有序集合生成流时会保留原有的序列。</td>
</tr>
<tr>
<td>数据处理操作</td>
<td>流的数据处理功能类似于数据库的操作，以及函数式编程语言中的常用操作，如filter、map、reduce、find、match、sort等。流操作可以顺序执行，也可以并行执行。</td>
</tr>
<tr>
<td>流水线</td>
<td>很多的流操作本身会返回一个流，这样多个操作就可以链接起来，形成一个流水线。</td>
</tr>
<tr>
<td>内部迭代</td>
<td>和使用迭代器进行显示迭代的集合不同，流的迭代操作是在背后进行的。</td>
</tr>
</tbody></table>
<h3 id="1-2-2-外部迭代与内部迭代"><a href="#1-2-2-外部迭代与内部迭代" class="headerlink" title="1.2.2 外部迭代与内部迭代"></a>1.2.2 外部迭代与内部迭代</h3><p>使用Collection接口需要用户自己去做迭代，称为<strong>外部迭代</strong>。</p>
<p>使用Stream进行的迭代是<strong>内部迭代</strong>，Stream已经帮你把迭代做了，你只需要告诉它你需要干什么就可以了。</p>
<p>外部迭代：<br><img src="../img/java8-out-iterator.PNG" alt="外部迭代"></p>
<p>内部迭代：<br><img src="../img/java8-inner-iterator.PNG"></p>
<h2 id="1-3-常见的流操作"><a href="#1-3-常见的流操作" class="headerlink" title="1.3 常见的流操作"></a>1.3 常见的流操作</h2><h3 id="1-3-1-collect-toList"><a href="#1-3-1-collect-toList" class="headerlink" title="1.3.1 collect(toList)"></a>1.3.1 collect(toList)</h3><p>collect(toList)方法由Stream里的值生成一个列表。of方法可以生成一个流对象。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">List&lt;String&gt; list = Stream.of(<span class="string">&quot;a&quot;</span>, <span class="string">&quot;b&quot;</span>, <span class="string">&quot;c&quot;</span>).collect(Collectors.toList());</span><br></pre></td></tr></table></figure>

<h3 id="1-3-2-map"><a href="#1-3-2-map" class="headerlink" title="1.3.2 map"></a>1.3.2 map</h3><p>map操作可以将一个流中的一种值转换成另一种类型的值，生成一个新的流(一对一映射)。比如，将一个集合中的字符串全部转换成大写。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">List&lt;String&gt; upperCaseList = Stream.of(<span class="string">&quot;talk&quot;</span>, <span class="string">&quot;is&quot;</span>, <span class="string">&quot;cheap&quot;</span>, <span class="string">&quot;,&quot;</span>, <span class="string">&quot;show&quot;</span>, <span class="string">&quot;me&quot;</span>, <span class="string">&quot;the&quot;</span>, <span class="string">&quot;code&quot;</span>)</span><br><span class="line">                .map(string -&gt; string.toUpperCase())</span><br><span class="line">                .collect(Collectors.toList());</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">    output:</span></span><br><span class="line"><span class="comment">    [TALK,IS,CHEAP,,,SHOW,ME,THE,CODE]</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure>

<p> <img src="../img/java8-map.PNG" alt="Java 8 map"></p>
<p>map操作传入的Lambda表达式必须和Function接口的签名一致。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">Function</span>&lt;<span class="title">T</span>, <span class="title">R</span>&gt; </span>&#123;</span><br><span class="line">    <span class="function">R <span class="title">apply</span><span class="params">(T t)</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="1-3-3-flatMap"><a href="#1-3-3-flatMap" class="headerlink" title="1.3.3 flatMap"></a>1.3.3 flatMap</h3><p>flatMap方法使一个流中的每个值都换成另外一个流，然后把所有的流都连接起来成为一个流（笛卡尔乘积）。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//找出两个数组中共同的元素，形成一个集合</span></span><br><span class="line"></span><br><span class="line">Integer[] array1 = &#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>, <span class="number">6</span>, <span class="number">7</span>, <span class="number">8</span>, <span class="number">9</span>&#125;;</span><br><span class="line">Integer[] array2 = &#123;<span class="number">2</span>, <span class="number">3</span>, <span class="number">5</span>, <span class="number">7</span>, <span class="number">11</span>&#125;;</span><br><span class="line">List&lt;Integer[]&gt; list = Stream</span><br><span class="line">                .of(array1)</span><br><span class="line">                .flatMap(a1 -&gt; Stream.of(array2).filter(a1::equals).map(a2 -&gt; <span class="keyword">new</span> Integer[]&#123;a1, a2&#125;))</span><br><span class="line">                .collect(Collectors.toList());</span><br><span class="line">  </span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">    output:</span></span><br><span class="line"><span class="comment">    [&lt;2, 2&gt;, &lt;3, 3&gt;, &lt;5, 5&gt;, &lt;7, 7&gt;]</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure>

<p>flatMap操作接收的Lambda表达式必须与Function接口的签名一致，传入的范型为Function&lt;? super T, ? extends Stream&lt;? extends R&gt;&gt;.</p>
<h3 id="1-3-4-filter"><a href="#1-3-4-filter" class="headerlink" title="1.3.4 filter"></a>1.3.4 filter</h3><p>filter用来遍历数据并选出符合特定条件的元素。比如筛选出一个字符串集合中仅含数字的字符串。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">List&lt;String&gt; digitList = Stream.of(<span class="string">&quot;a1c&quot;</span>, <span class="string">&quot;123&quot;</span>, <span class="string">&quot;1q2qw&quot;</span>, <span class="string">&quot;0.5&quot;</span>)</span><br><span class="line">                .filter(string -&gt; TextUtils.isDigitsOnly(string))</span><br><span class="line">                .collect(Collectors.toList());</span><br><span class="line">                </span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">    output:</span></span><br><span class="line"><span class="comment">    [123]</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure>

<p><img src="../img/java8-filter.PNG"></p>
<p>同样，filter操作传入的Lambda表达式必须和Predicate接口的签名一致。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">Predicate</span>&lt;<span class="title">T</span>&gt; </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">boolean</span> <span class="title">test</span><span class="params">(T t)</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="1-3-5-distinct"><a href="#1-3-5-distinct" class="headerlink" title="1.3.5 distinct"></a>1.3.5 distinct</h3><p>disdint方法会返回一个元素各异的流，简单来说，就是滤重（根据元素的hashCode和equals方法）。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">List&lt;Integer&gt; distinctList = Stream.of(<span class="number">1</span>, <span class="number">1</span>, <span class="number">2</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">3</span>, <span class="number">3</span>, <span class="number">4</span>)</span><br><span class="line">                .distinct()</span><br><span class="line">                .collect(Collectors.toList());</span><br><span class="line">    </span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">    output:</span></span><br><span class="line"><span class="comment">    [1,2,3,4]</span></span><br><span class="line"><span class="comment">*/</span>    </span><br></pre></td></tr></table></figure>

<h3 id="1-3-6-limit"><a href="#1-3-6-limit" class="headerlink" title="1.3.6 limit"></a>1.3.6 limit</h3><p>limit(n)会返回一个不超过给定长度的流。如果流是有序的，则最多会返回前n个元素。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">List&lt;Integer&gt; list = Stream.of(<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>, <span class="number">6</span>, <span class="number">7</span>)</span><br><span class="line">                .limit(<span class="number">3</span>)</span><br><span class="line">                .collect(Collectors.toList());</span><br><span class="line">    </span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">    output:</span></span><br><span class="line"><span class="comment">    [1,2,3]</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure>

<h3 id="1-3-7-skip"><a href="#1-3-7-skip" class="headerlink" title="1.3.7 skip"></a>1.3.7 skip</h3><p>skip(n)，会返回扔掉前n个元素的流，如果流中元素不超过n，则会返回一个空的流。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">List&lt;Integer&gt; list = Stream.of(<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>, <span class="number">6</span>, <span class="number">7</span>)</span><br><span class="line">                .skip(<span class="number">3</span>)</span><br><span class="line">                .collect(Collectors.toList());</span><br><span class="line">    </span><br><span class="line"><span class="comment">/*    </span></span><br><span class="line"><span class="comment">    output:</span></span><br><span class="line"><span class="comment">    [4,5,6,7]</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure>

<h3 id="1-3-8-min和max"><a href="#1-3-8-min和max" class="headerlink" title="1.3.8 min和max"></a>1.3.8 min和max</h3><p>求最小值和求最大值。比如求菜品集合中价格最低和最高的菜。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">List&lt;Dish&gt; dishes = ...</span><br><span class="line">Dish max = dishes.stream()</span><br><span class="line">    .max(Comparator.comparing(dish -&gt; dish.getPrice))</span><br><span class="line">    .get();</span><br><span class="line">    </span><br><span class="line">Dish min = dishes.stream()</span><br><span class="line">    .mix(Comparator.comparing(dish -&gt; dish.getPrice))</span><br><span class="line">    .get();</span><br></pre></td></tr></table></figure>

<h3 id="1-3-9-reduce"><a href="#1-3-9-reduce" class="headerlink" title="1.3.9 reduce"></a>1.3.9 reduce</h3><p>reduce操作可以从一组值中生成一个值，实际上max和min也是reduce操作，因为太常用，所以被纳入了标准库中。举例，求和：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">int</span> sum = Stream.of(<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>)</span><br><span class="line">    .reduce(<span class="number">0</span>, (acc, element) -&gt; acc + element);</span><br></pre></td></tr></table></figure>

<p><img src="../img/java8-reduce.PNG" alt="reduce"></p>
<p>reduce对应的操作有3个重载的方法：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//无初始值的</span></span><br><span class="line"><span class="function">Optional&lt;T&gt; <span class="title">reduce</span><span class="params">(BinaryOperator&lt;T&gt; accumulator)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">//等价于</span></span><br><span class="line"><span class="keyword">boolean</span> foundAny = <span class="keyword">false</span>;</span><br><span class="line">T result = <span class="keyword">null</span>;</span><br><span class="line"><span class="keyword">for</span> (T element : <span class="keyword">this</span> stream) &#123;</span><br><span class="line">    <span class="keyword">if</span> (!foundAny) &#123;</span><br><span class="line">       foundAny = <span class="keyword">true</span>;</span><br><span class="line">        result = element;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        result = accumulator.apply(result, element);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> foundAny ? Optional.of(result) : Optional.empty();</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//带初始值的</span></span><br><span class="line"><span class="function">T <span class="title">reduce</span><span class="params">(T identity, BinaryOperator&lt;T&gt; accumulator)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">//等价于</span></span><br><span class="line">T result = identity;</span><br><span class="line"><span class="keyword">for</span> (T element : <span class="keyword">this</span> stream)</span><br><span class="line">    result = accumulator.apply(result, element)</span><br><span class="line"><span class="keyword">return</span> result;</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//参数带两个BiFuction的</span></span><br><span class="line">&lt;U&gt; <span class="function">U <span class="title">reduce</span><span class="params">(U identity,</span></span></span><br><span class="line"><span class="function"><span class="params">                BiFunction&lt;U, ? <span class="keyword">super</span> T, U&gt; accumulator,</span></span></span><br><span class="line"><span class="function"><span class="params">             BinaryOperator&lt;U&gt; combiner)</span></span>;</span><br><span class="line">             </span><br><span class="line"><span class="comment">//等价于</span></span><br><span class="line">U result = identity;</span><br><span class="line"><span class="keyword">for</span> (T element : <span class="keyword">this</span> stream)</span><br><span class="line">    result = accumulator.apply(result, element)</span><br><span class="line"><span class="keyword">return</span> result;</span><br></pre></td></tr></table></figure>

<h3 id="1-3-10-anyMatch、allMatch和noneMatch"><a href="#1-3-10-anyMatch、allMatch和noneMatch" class="headerlink" title="1.3.10 anyMatch、allMatch和noneMatch"></a>1.3.10 anyMatch、allMatch和noneMatch</h3><p>anyMatch判断流中是否至少有一个元素能匹配给定的条件，返回一个boolean值。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">boolean</span> hasNullElements = Stream.of(<span class="string">&quot;Java&quot;</span>, <span class="string">&quot;Python&quot;</span>, <span class="string">&quot;C#&quot;</span>, <span class="keyword">null</span>, <span class="string">&quot;Ruby&quot;</span>, <span class="string">&quot;Go&quot;</span>, <span class="string">&quot;Object C&quot;</span>)</span><br><span class="line">               .anyMatch(Objects::isNull);</span><br></pre></td></tr></table></figure>

<p>allMatch检查流中流中所有元素是否匹配给定的条件，返回boolean值。</p>
<p>noneMatch检查流中所以元素是否都不匹配给定的条件，返回boolean值。</p>
<h3 id="1-3-11-findAny与findFirst"><a href="#1-3-11-findAny与findFirst" class="headerlink" title="1.3.11 findAny与findFirst"></a>1.3.11 findAny与findFirst</h3><p>findAny找到流中任意一个元素(通常是第一个)，返回一个Optional对象，如果流是空的，返回一个值为空的Optional对象，如果找到的元素刚好是空值，则抛出一个NullPointerException。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">Optional</span>&lt;<span class="title">T</span>&gt; </span>&#123;</span><br><span class="line">    T t;</span><br><span class="line">    <span class="comment">//...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>例：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Optional&lt;Integer&gt; optional = Stream.of(<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>, <span class="number">6</span>, <span class="number">7</span>)</span><br><span class="line">                .findAny();</span><br><span class="line">                </span><br><span class="line"><span class="comment">//执行多次optional.get()始终是1</span></span><br></pre></td></tr></table></figure>
<p>如果使用的是并行的流，那么findAny方法返回的值则是不确定的，比如下面的例子：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">List&lt;Integer&gt; array = Arrays.asList(<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>, <span class="number">6</span>, <span class="number">7</span>);</span><br><span class="line">Printer.println(array.parallelStream().findAny().get());</span><br><span class="line">Printer.println(array.parallelStream().findAny().get());</span><br><span class="line">Printer.println(array.parallelStream().findAny().get());</span><br><span class="line">Printer.println(array.parallelStream().findAny().get());</span><br><span class="line"></span><br><span class="line"><span class="comment">/* 执行多次返回值分别是：</span></span><br><span class="line"><span class="comment">第1次：</span></span><br><span class="line"><span class="comment">5</span></span><br><span class="line"><span class="comment">5</span></span><br><span class="line"><span class="comment">5</span></span><br><span class="line"><span class="comment">5</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">Process finished with exit code 0</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">第2次：</span></span><br><span class="line"><span class="comment">4</span></span><br><span class="line"><span class="comment">7</span></span><br><span class="line"><span class="comment">2</span></span><br><span class="line"><span class="comment">6</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">Process finished with exit code 0</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure>
<p>findAny操作一般和filter结合起来用，用于筛选。</p>
<p>如果想始终找到第一个元素，则应该用findFirst操作，即使是并行的流，页始终能返回第一个元素。</p>
<p><em>短路求值：对于有些操作，不必处理整个流就能得到结果，就像用 || 连接起来的布尔表达式求值一样，只要提前找到一个为true的值就直接返回。流的操作中，anyMatch、findAny、findFirst都是短路操作，limit也是。</em></p>
<h2 id="1-4-流与集合"><a href="#1-4-流与集合" class="headerlink" title="1.4 流与集合"></a>1.4 流与集合</h2><h3 id="1-4-1-流与集合概念的差异"><a href="#1-4-1-流与集合概念的差异" class="headerlink" title="1.4.1 流与集合概念的差异"></a>1.4.1 流与集合概念的差异</h3><p>从前面的例子中可以看到，通过Stream.of(…)方法可以得到一个流对象，看起来数据源似乎是保存在了流对象中，这和集合中保存一组数据很类似。但是，最终从流中获取一个集合，还需要调用collect(toList())方法，由此可见，流并不是集合。</p>
<p>流与集合到底有什么差异呢？举一个形象的例子，存在DVD中的电影，这就是一个集合，因为它包含了电影的全部数据，而网上在线播放的视频则是一个视频流，它只加载你当前观看的这几帧，不用等到所有的数据都加载完了才能看。</p>
<p>所以简单来讲，集合与流之间的差异就在于何时进行计算。集合是内存中的一种数据结构，它包含了数据源的所有值，集合的每个元素都需要先计算出来然后再加入到集合中。而流的元素则是按需计算，仅仅在用户需要的时候才会提取值，这是一种生产者—消费者的关系，只有消费者要求的时候才会去计算值。</p>
<h3 id="1-4-2-流只能遍历一次"><a href="#1-4-2-流只能遍历一次" class="headerlink" title="1.4.2 流只能遍历一次"></a>1.4.2 流只能遍历一次</h3><p>和迭代器类似，流只能遍历一次，遍历完成之后，这个流就已经被消费掉了。如果想再次遍历，需从数据源重新获取一个流（如果数据源是可重复的比如集合，这会很容易，但如果像I/O这种的话，就会很麻烦）。</p>
<p>重复消费一个流会抛出IllegalArgumentException，表示流已经被操作，或者关闭。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">List&lt;String&gt; firms &#x3D; Arrays.asList(&quot;Google&quot;, &quot;AT&amp;T&quot;, &quot;Amazon&quot;, &quot;Facebook&quot;, &quot;Oracle&quot;, &quot;MicroSoft&quot;);</span><br><span class="line">Stream&lt;String&gt; stream &#x3D; Stream.of(firms);</span><br><span class="line">stream.forEach(System.out::println);</span><br><span class="line">stream.forEach(System.out::println);</span><br></pre></td></tr></table></figure>

<h2 id="1-5-流的构建"><a href="#1-5-流的构建" class="headerlink" title="1.5 流的构建"></a>1.5 流的构建</h2><h3 id="1-5-1-数值流"><a href="#1-5-1-数值流" class="headerlink" title="1.5.1 数值流"></a>1.5.1 数值流</h3><p>在有些流的操作中，流中的元素如果是数值，会不可避免的产生装箱和拆箱的操作，比如，对菜品的价格求和：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">List&lt;Dish&gt; dishes ...</span><br><span class="line">int sumPrice &#x3D; dishes.stream()</span><br><span class="line">        .map(Dish::getPrice)</span><br><span class="line">        .reduce(0, Integer::sum);</span><br><span class="line">&#96;&#96;&#96; </span><br><span class="line">这段代码中，map操作会生成一个Stream&lt;T&gt;的流，因此，就需要将int类型装箱成Integer。在Java 8的Stream API中，为了避免这种拆装箱，提供了原始类型流特化，专门支持处理数值流。</span><br><span class="line"></span><br><span class="line">#### 1.5.1.1 原始类型流特化</span><br><span class="line"></span><br><span class="line">Java 8中引入的原始类型流特化流有3个：IntStream、LongStream和DoubleStream，分别将流的元素特化为对应的基础类型。相应的这些流中也多了一些常用的数值操作，比如sum, average, max, min等。</span><br><span class="line"></span><br><span class="line">将流转化成特定的数值流常用的操作是map，对应的，map操作也有几个特定的方法，mapToInt、mapToLong、mapToDouble。比如上面对菜品价格求和的操作，就可以用IntStream来做：</span><br><span class="line"></span><br><span class="line">&#96;&#96;&#96;Java</span><br><span class="line">List&lt;Dish&gt; dishes ...</span><br><span class="line">int sumPrice &#x3D; dishes.stream()</span><br><span class="line">        .mapToInt(Dish::getPrice)</span><br><span class="line">        .sum;</span><br></pre></td></tr></table></figure>

<p>有时候，也会有将数值流转回对象流的需求，这时候只需要将基础元素进行装箱操作就可以，使用的操作是boxed。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">IntStream intSream = dishes.stream()</span><br><span class="line">        .mapToInt(Dish::getPrice);</span><br><span class="line">Stream&lt;Integer&gt; stream = intStream.boxed();</span><br></pre></td></tr></table></figure>

<p>上面讲findAny和findFirst操作的时候，提到了Optional对象，类似的，Optional类也对数值的基础类型进行了特化，有IntOptitonal、LongOptional和DoubleOptional三个类。</p>
<h4 id="1-5-1-2-数值范围"><a href="#1-5-1-2-数值范围" class="headerlink" title="1.5.1.2 数值范围"></a>1.5.1.2 数值范围</h4><p>Java 8引入了两个可以用于InStream和LongStream的静态方法，range和rangeClose。区别是range不包含结束值，rangeClosed包含结束值。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">IntStream intStream = IntStream.range(<span class="number">1</span>, <span class="number">10</span>);</span><br><span class="line">        <span class="keyword">int</span>[] array = intStream.toArray();</span><br><span class="line">        Printer.print(array);</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">    output:</span></span><br><span class="line"><span class="comment">    [1,2,3,4,5,6,7,8,9]</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">IntStream intStream = IntStream.rangeClosed(<span class="number">1</span>, <span class="number">10</span>);</span><br><span class="line">        <span class="keyword">int</span>[] array = intStream.toArray();</span><br><span class="line">        Printer.print(array);</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">    output:</span></span><br><span class="line"><span class="comment">    [1,2,3,4,5,6,7,8,9,10]</span></span><br></pre></td></tr></table></figure>

<h3 id="1-5-2-构建流的几种方式"><a href="#1-5-2-构建流的几种方式" class="headerlink" title="1.5.2 构建流的几种方式"></a>1.5.2 构建流的几种方式</h3><h4 id="1-5-2-1-由值创建流"><a href="#1-5-2-1-由值创建流" class="headerlink" title="1.5.2.1 由值创建流"></a>1.5.2.1 由值创建流</h4><p>使用Stream.of(T t …)方法可以创建出一个流，Stream.empty()可以创建一个没有元素的流：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Stream&lt;String&gt; stringStream = Stream.of(<span class="string">&quot;Apple&quot;</span>, <span class="string">&quot;MicroSoft&quot;</span>, <span class="string">&quot;Google&quot;</span>, <span class="string">&quot;Facebook&quot;</span>, <span class="string">&quot;Amazon&quot;</span>);</span><br><span class="line">Stream&lt;String&gt; emptyStream = Stream.empty();</span><br></pre></td></tr></table></figure>

<h4 id="1-5-2-2-由数组创建流"><a href="#1-5-2-2-由数组创建流" class="headerlink" title="1.5.2.2 由数组创建流"></a>1.5.2.2 由数组创建流</h4><p>Arrays.stream可以从数组创建一个流，参数是一个数组。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">String[] stringArray = &#123;<span class="string">&quot;Apple&quot;</span>, <span class="string">&quot;MicroSoft&quot;</span>, <span class="string">&quot;Google&quot;</span>, <span class="string">&quot;Facebook&quot;</span>, <span class="string">&quot;Amazon&quot;</span>&#125;;</span><br><span class="line"><span class="keyword">int</span>[] intArray = &#123;<span class="number">0</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">5</span>, <span class="number">8</span>, <span class="number">13</span>, <span class="number">21</span>&#125;;</span><br><span class="line">        </span><br><span class="line">Stream&lt;String&gt; stringStream = Arrays.stream(stringArray);</span><br><span class="line">IntStream intStream = Arrays.stream(intArray);</span><br><span class="line">Stream&lt;Integer&gt; integerStream = Arrays.stream(intArray).boxed();</span><br></pre></td></tr></table></figure>

<h4 id="1-5-2-3-由集合生成流"><a href="#1-5-2-3-由集合生成流" class="headerlink" title="1.5.2.3 由集合生成流"></a>1.5.2.3 由集合生成流</h4><p>Java的Collection接口中，引入了stream()和parallelStream()两个默认方法，可以生成流。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">String[] stringArray = &#123;<span class="string">&quot;Apple&quot;</span>, <span class="string">&quot;MicroSoft&quot;</span>, <span class="string">&quot;Google&quot;</span>, <span class="string">&quot;Facebook&quot;</span>, <span class="string">&quot;Amazon&quot;</span>&#125;;</span><br><span class="line">List&lt;String&gt; list = Arrays.asList(stringArray);</span><br><span class="line">Stream&lt;String&gt; stream = list.stream();</span><br><span class="line">Stream&lt;String&gt; parallelStream = list.parallelStream();</span><br></pre></td></tr></table></figure>

<h4 id="1-5-2-4-由文件生成流"><a href="#1-5-2-4-由文件生成流" class="headerlink" title="1.5.2.4 由文件生成流"></a>1.5.2.4 由文件生成流</h4><p>Java 8的NIO API中，很多操作都可以返回一个流。比如，Files.lines就会根据文件内容返回一个流。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">            Stream&lt;String&gt; lines = Files.lines(Paths.get(<span class="string">&quot;.gitignore&quot;</span>), Charset.forName(<span class="string">&quot;utf-8&quot;</span>))</span><br><span class="line">                    .flatMap(line -&gt; Arrays.stream(line.split(<span class="string">&quot; &quot;</span>)));</span><br><span class="line">            lines.forEach(word -&gt; Printer.println(word));</span><br><span class="line">        &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h4 id="1-5-2-5-由函数生成流：创建无限流"><a href="#1-5-2-5-由函数生成流：创建无限流" class="headerlink" title="1.5.2.5 由函数生成流：创建无限流"></a>1.5.2.5 由函数生成流：创建无限流</h4><p>Stream API中提供了2个静态方法来从方法中生成流：Stream.iterate和Stream.generate，这2个方法都可以用来创建无限流，只要不结束，可以一直算下去。</p>
<p><strong>iterate</strong></p>
<p>iterate方法有两个重载的方法：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//有结束条件的</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span>&lt;T&gt; Stream&lt;T&gt; <span class="title">iterate</span><span class="params">(T seed, Predicate&lt;? <span class="keyword">super</span> T&gt; hasNext, UnaryOperator&lt;T&gt; next)</span></span></span><br></pre></td></tr></table></figure>
<p>和</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//没有限制，可以真正生成无限流</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span>&lt;T&gt; Stream&lt;T&gt; <span class="title">iterate</span><span class="params">(<span class="keyword">final</span> T seed, <span class="keyword">final</span> UnaryOperator&lt;T&gt; f)</span></span></span><br></pre></td></tr></table></figure>

<p>例如，生成一个斐波那契数列：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Stream.iterate(<span class="keyword">new</span> <span class="keyword">int</span>[]&#123;<span class="number">0</span>, <span class="number">1</span>&#125;,  t -&gt; <span class="keyword">new</span> <span class="keyword">int</span>[] &#123;t[<span class="number">1</span>], t[<span class="number">0</span>] + t[<span class="number">1</span>]&#125;)</span><br><span class="line">                .map(t -&gt; t[<span class="number">0</span>])</span><br><span class="line">                .limit(<span class="number">20</span>)</span><br><span class="line">                .forEach(Printer::println);</span><br></pre></td></tr></table></figure>


<p><strong>generate</strong></p>
<p>和iterate方法类似，generate也生成一个无限流。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span>&lt;T&gt; Stream&lt;T&gt; <span class="title">generate</span><span class="params">(Supplier&lt;? extends T&gt; s)</span></span></span><br></pre></td></tr></table></figure>

<p>generate方法的参数是一个Supplier，它可以是无状态的，也可以是有状态的。</p>
<p>无状态的Supplier，不会记录上一个状态，比如生成随机数，</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Stream.generate(Math::random)</span><br><span class="line">                .limit(<span class="number">20</span>)</span><br><span class="line">                .forEach(Printer::println);</span><br></pre></td></tr></table></figure>
<p>有状态的Supplier还可以是有状态的，它会记录前一个Supplier的状态（可以是值，属性等），比如还是生成一个斐波那契数列，在构建每一个元素时，都改变了supplier的属性：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">IntSupplier supplier = <span class="keyword">new</span> IntSupplier() &#123;</span><br><span class="line">            <span class="keyword">private</span> <span class="keyword">int</span> pre = <span class="number">0</span>;</span><br><span class="line">            <span class="keyword">private</span> <span class="keyword">int</span> cur = <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">getAsInt</span><span class="params">()</span> </span>&#123;</span><br><span class="line">                <span class="keyword">int</span> oldPre = pre;</span><br><span class="line">                <span class="keyword">int</span> oldCur = cur;</span><br><span class="line">                <span class="keyword">this</span>.pre = cur;</span><br><span class="line">                <span class="keyword">this</span>.cur = oldPre + oldCur;</span><br><span class="line">                <span class="keyword">return</span> oldPre;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;;</span><br><span class="line">        IntStream.generate(supplier)</span><br><span class="line">                .limit(<span class="number">20</span>)</span><br><span class="line">                .forEach(Printer::println);</span><br></pre></td></tr></table></figure>

<hr>
<p>Author: Ivan J. Lee<br>Date  : 2017-12-27 23:56</p>
]]></content>
      <tags>
        <tag>java</tag>
      </tags>
  </entry>
</search>
